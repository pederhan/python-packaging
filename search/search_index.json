{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Improving Python Project Packaging This document outlines the current state of the art for Python dependency management and packaging tooling, and aims to propose a set of changes to current and future Python projects to improve the development experience and make it easier to develop and publish Python packages. Abstract Python packaging and practices for managing development environments have changed significantly over the past few years. Modern developments such as pyproject.toml , and more advanced dependency resolvers, virtual environment, building, and publising tooling allows for a more streamlined and unified development experience. To achieve this, a number of tools are evaluated and compared, and a set of recommendations are proposed for the future of our Python project packaging and dependency management. Packaging Tools Packaging Python projects and managing virtual environments has become a lot easier in recent years if you know what you're doing, but if you don't, it just looks like a sea of tools doing a lot of the same things. This section aims to clarify the differences between the various tools and how they fit together. The most popular tools are looked at in turn to evaluate their strengths and weaknesses, and how they can be used together. Popularity of Tools Comparison Using Absolute Publication Time Comparison Using Relative Publication Time","title":"Improving Python Project Packaging"},{"location":"#improving-python-project-packaging","text":"This document outlines the current state of the art for Python dependency management and packaging tooling, and aims to propose a set of changes to current and future Python projects to improve the development experience and make it easier to develop and publish Python packages.","title":"Improving Python Project Packaging"},{"location":"#abstract","text":"Python packaging and practices for managing development environments have changed significantly over the past few years. Modern developments such as pyproject.toml , and more advanced dependency resolvers, virtual environment, building, and publising tooling allows for a more streamlined and unified development experience. To achieve this, a number of tools are evaluated and compared, and a set of recommendations are proposed for the future of our Python project packaging and dependency management.","title":"Abstract"},{"location":"#packaging-tools","text":"Packaging Python projects and managing virtual environments has become a lot easier in recent years if you know what you're doing, but if you don't, it just looks like a sea of tools doing a lot of the same things. This section aims to clarify the differences between the various tools and how they fit together. The most popular tools are looked at in turn to evaluate their strengths and weaknesses, and how they can be used together.","title":"Packaging Tools"},{"location":"#popularity-of-tools","text":"","title":"Popularity of Tools"},{"location":"#comparison-using-absolute-publication-time","text":"","title":"Comparison Using Absolute Publication Time"},{"location":"#comparison-using-relative-publication-time","text":"","title":"Comparison Using Relative Publication Time"},{"location":"conclusion/","text":"Conclusion TL;DR What follows is a brief overview of the differences between the tools that are evaluated, as well as their popularity. Features pyproject.toml PEP 621 Compliant Virtual Environment Management Dependency Resolution Pinning Building Reproducible Builds Publishing Poetry PDM Pipenv Flit pip-tools Hatch Popularity These graphs show the number of stars on GitHub for each tool in relation to publication time. The graphs are generated using star-history . Comparison Using Absolute Publication Time This chart shows the popularity of each tool in relation to its publication time. The x-axis shows the date of publication, and the y-axis shows the number of stars on GitHub. Comparison Using Relative Publication Time This chart shows the popularity of the tools in relation to the time since their publication. The x-axis shows number of years since publication, and the y-axis shows number of stars on GitHub. Unmentioned Tools Twine Enscons Tool for building source distributions and wheels without setuptools , including ones that require C extensions. PyPI link: https://pypi.org/project/enscons/ Further Reading Below are the most relevant PEPs with regards to modern packaging and building of Python projects with pyproject.toml as well as other relevant reading material. PEPs PEP 518 - Specifying Minimum Build System Requirements for Python Projects PEP 621 - Storing project metadata in pyproject.toml Relevant Links Full list of modern packaging PEPs (508 and onwards) Clarifying PEP 518 (a.k.a. pyproject.toml) pyproject.toml specification TIL: pip-tools Supports pyproject.toml Hypermodern Python Insofar as GitHub stars are a good metric to determine this. https://pypi.org/project/darker/#:~:text=command%20line%20options-,Editor%20integration,-Many%20editors%20have https://moyix.blogspot.com/2022/09/someones-been-messing-with-my-subnormals.html#:~:text=I%20actually%20started,home%20directory.%20Convenient!","title":"Conclusion"},{"location":"conclusion/#conclusion","text":"","title":"Conclusion"},{"location":"conclusion/#tldr","text":"What follows is a brief overview of the differences between the tools that are evaluated, as well as their popularity.","title":"TL;DR"},{"location":"conclusion/#features","text":"pyproject.toml PEP 621 Compliant Virtual Environment Management Dependency Resolution Pinning Building Reproducible Builds Publishing Poetry PDM Pipenv Flit pip-tools Hatch","title":"Features"},{"location":"conclusion/#popularity","text":"These graphs show the number of stars on GitHub for each tool in relation to publication time. The graphs are generated using star-history .","title":"Popularity"},{"location":"conclusion/#comparison-using-absolute-publication-time","text":"This chart shows the popularity of each tool in relation to its publication time. The x-axis shows the date of publication, and the y-axis shows the number of stars on GitHub.","title":"Comparison Using Absolute Publication Time"},{"location":"conclusion/#comparison-using-relative-publication-time","text":"This chart shows the popularity of the tools in relation to the time since their publication. The x-axis shows number of years since publication, and the y-axis shows number of stars on GitHub.","title":"Comparison Using Relative Publication Time"},{"location":"conclusion/#unmentioned-tools","text":"","title":"Unmentioned Tools"},{"location":"conclusion/#twine","text":"","title":"Twine"},{"location":"conclusion/#enscons","text":"Tool for building source distributions and wheels without setuptools , including ones that require C extensions. PyPI link: https://pypi.org/project/enscons/","title":"Enscons"},{"location":"conclusion/#further-reading","text":"Below are the most relevant PEPs with regards to modern packaging and building of Python projects with pyproject.toml as well as other relevant reading material.","title":"Further Reading"},{"location":"conclusion/#peps","text":"PEP 518 - Specifying Minimum Build System Requirements for Python Projects PEP 621 - Storing project metadata in pyproject.toml","title":"PEPs"},{"location":"conclusion/#relevant-links","text":"Full list of modern packaging PEPs (508 and onwards) Clarifying PEP 518 (a.k.a. pyproject.toml) pyproject.toml specification TIL: pip-tools Supports pyproject.toml Hypermodern Python Insofar as GitHub stars are a good metric to determine this. https://pypi.org/project/darker/#:~:text=command%20line%20options-,Editor%20integration,-Many%20editors%20have https://moyix.blogspot.com/2022/09/someones-been-messing-with-my-subnormals.html#:~:text=I%20actually%20started,home%20directory.%20Convenient!","title":"Relevant Links"},{"location":"pyproject/","text":"pyproject.toml pyproject.toml is the modern replacement for setup.py , setup.cfg , requirements.txt and MANIFEST.in . It is a file that contains metadata about the project, as well as a list of build dependencies,build instructions, and tool configuration. It is a TOML configuration file, which means it does not present a risk of arbitrary code execution like setup.py n when reading project metadata. The file can specify build dependencies without running any Python code; it is purely declarative. This is important because it allows the build dependencies to be specified in a way that is compatible with all Python packaging tools, including tools that do not use setuptools . The pyproject.toml file unifies multiple facets of project packaging and development. It is a single source of truth for the project metadata, build dependencies, build instructions, as well as tool configuration. The following sections are based on PEP 517 , PEP 518 and PEP 621 , which together make up the PEPs that define pyproject.toml . Build system specification # pyproject.toml [build-system] requires = [ \"setuptools>=42\" , \"wheel\" ] build-backend = \"setuptools.build_meta\" # ... Metadata specification # pyproject.toml # ... [project] name = \"my-package\" version = \"0.1.0\" description = \"A short description of my package\" authors = [ { name = \"Author Name\" , email = \"user@example.com\" }, ] readme = \"README.md\" requires-python = \">=3.6\" license = { file = \"LICENSE\" } classifiers = [ \"Development Status :: 3 - Alpha\" , \"Intended Audience :: Developers\" , \"License :: OSI Approved :: MIT License\" , \"Programming Language :: Python :: 3\" , \"Programming Language :: Python :: 3.6\" , \"Programming Language :: Python :: 3.7\" , \"Programming Language :: Python :: 3.8\" , \"Programming Language :: Python :: 3.9\" , ] keywords = [ \"keyword1\" , \"keyword2\" , \"keyword3\" ] The [project] table contains the project metadata for the project. The full specification for the project metadata can be found here . Dependency specification # pyproject.toml # ... [project] # ... dependencies = [ \"package1\" , \"package2>=2.0\" , \"package3[extra1,extra2]\" , \"package4==0.4.0; python_version<'3.7'\" ] optional-dependencies = { \"extra1\" : [ \"package5\" ], \"extra2\" : [ \"package6\" ], } This is the standard dependency specification when building a project with setuptools . The full specification for the dependency specification can be found here . Other build tools usually use their own dependency specification for optional dependencies (and sometimes core dependencies), but they will still ultimately live inside the pyproject.toml file. Tool configuration pyproject.toml is able to unify the configuration options for a multitude of tools including build tools, linters, formatters, and more. This allows the configuration for all of these tools to be specified in a single file, as opposed to having one file for each tool. This makes it easier to manage tool configuration. Examples of tools that support pyproject.toml include: Pytest Coverage.py Tox MyPy Black Flake8 And more... Example: # pyproject.toml # ... [tool.isort] profile = \"black\" [tool.pytest.ini_options] asyncio_mode = \"auto\" [tool.mypy] strict = true exclude = [ \"tests/\" ] Full pyproject.toml Example The following shows a full example of a pyproject.toml file that contains all of the above sections.","title":"pyproject.toml"},{"location":"pyproject/#pyprojecttoml","text":"pyproject.toml is the modern replacement for setup.py , setup.cfg , requirements.txt and MANIFEST.in . It is a file that contains metadata about the project, as well as a list of build dependencies,build instructions, and tool configuration. It is a TOML configuration file, which means it does not present a risk of arbitrary code execution like setup.py n when reading project metadata. The file can specify build dependencies without running any Python code; it is purely declarative. This is important because it allows the build dependencies to be specified in a way that is compatible with all Python packaging tools, including tools that do not use setuptools . The pyproject.toml file unifies multiple facets of project packaging and development. It is a single source of truth for the project metadata, build dependencies, build instructions, as well as tool configuration. The following sections are based on PEP 517 , PEP 518 and PEP 621 , which together make up the PEPs that define pyproject.toml .","title":"pyproject.toml"},{"location":"pyproject/#build-system-specification","text":"# pyproject.toml [build-system] requires = [ \"setuptools>=42\" , \"wheel\" ] build-backend = \"setuptools.build_meta\" # ...","title":"Build system specification"},{"location":"pyproject/#metadata-specification","text":"# pyproject.toml # ... [project] name = \"my-package\" version = \"0.1.0\" description = \"A short description of my package\" authors = [ { name = \"Author Name\" , email = \"user@example.com\" }, ] readme = \"README.md\" requires-python = \">=3.6\" license = { file = \"LICENSE\" } classifiers = [ \"Development Status :: 3 - Alpha\" , \"Intended Audience :: Developers\" , \"License :: OSI Approved :: MIT License\" , \"Programming Language :: Python :: 3\" , \"Programming Language :: Python :: 3.6\" , \"Programming Language :: Python :: 3.7\" , \"Programming Language :: Python :: 3.8\" , \"Programming Language :: Python :: 3.9\" , ] keywords = [ \"keyword1\" , \"keyword2\" , \"keyword3\" ] The [project] table contains the project metadata for the project. The full specification for the project metadata can be found here .","title":"Metadata specification"},{"location":"pyproject/#dependency-specification","text":"# pyproject.toml # ... [project] # ... dependencies = [ \"package1\" , \"package2>=2.0\" , \"package3[extra1,extra2]\" , \"package4==0.4.0; python_version<'3.7'\" ] optional-dependencies = { \"extra1\" : [ \"package5\" ], \"extra2\" : [ \"package6\" ], } This is the standard dependency specification when building a project with setuptools . The full specification for the dependency specification can be found here . Other build tools usually use their own dependency specification for optional dependencies (and sometimes core dependencies), but they will still ultimately live inside the pyproject.toml file.","title":"Dependency specification"},{"location":"pyproject/#tool-configuration","text":"pyproject.toml is able to unify the configuration options for a multitude of tools including build tools, linters, formatters, and more. This allows the configuration for all of these tools to be specified in a single file, as opposed to having one file for each tool. This makes it easier to manage tool configuration. Examples of tools that support pyproject.toml include: Pytest Coverage.py Tox MyPy Black Flake8 And more... Example: # pyproject.toml # ... [tool.isort] profile = \"black\" [tool.pytest.ini_options] asyncio_mode = \"auto\" [tool.mypy] strict = true exclude = [ \"tests/\" ]","title":"Tool configuration"},{"location":"pyproject/#full-pyprojecttoml-example","text":"The following shows a full example of a pyproject.toml file that contains all of the above sections.","title":"Full pyproject.toml Example"},{"location":"tools/","text":"Packaging and Project Management Tools Packaging Python projects and managing virtual environments has become a lot easier in recent years if you know what you're doing, but if you don't, it can tend to look like an ocean of tools doing a lot of the same things. This section aims to clarify the differences between the various tools and how they fit together. The most popular tools are looked at in turn to evaluate their strengths and weaknesses, and how they can be used together. Skip to TL;DR for a summary of the findings of this section. Otherwise, head to the next page for a more in-depth look at the various tools available for packaging and project management. TL;DR What follows is a brief overview of the differences between the tools that are evaluated, as well as their popularity. Features pyproject.toml PEP 621 Compliant Virtual Environment Management Dependency Resolution Pinning Building Reproducible Builds Publishing Poetry PDM Pipenv Flit pip-tools Hatch Popularity These graphs show the number of stars on GitHub for each tool in relation to publication time. The graphs are generated using star-history . Comparison Using Absolute Publication Time This chart shows the popularity of each tool in relation to its publication time. The x-axis shows the date of publication, and the y-axis shows the number of stars on GitHub. Comparison Using Relative Publication Time This chart shows the popularity of the tools in relation to the time since their publication. The x-axis shows number of years since publication, and the y-axis shows number of stars on GitHub. Unmentioned Tools Twine Enscons Tool for building source distributions and wheels without setuptools , including ones that require C extensions. PyPI link: https://pypi.org/project/enscons/ Further Reading Below are the most relevant PEPs with regards to modern packaging and building of Python projects with pyproject.toml as well as other relevant reading material. PEPs PEP 518 - Specifying Minimum Build System Requirements for Python Projects PEP 621 - Storing project metadata in pyproject.toml Relevant Links Full list of modern packaging PEPs (508 and onwards) Clarifying PEP 518 (a.k.a. pyproject.toml) pyproject.toml specification TIL: pip-tools Supports pyproject.toml Hypermodern Python Insofar as GitHub stars are a good metric to determine this. https://pypi.org/project/darker/#:~:text=command%20line%20options-,Editor%20integration,-Many%20editors%20have https://moyix.blogspot.com/2022/09/someones-been-messing-with-my-subnormals.html#:~:text=I%20actually%20started,home%20directory.%20Convenient!","title":"Packaging and Project Management Tools"},{"location":"tools/#packaging-and-project-management-tools","text":"Packaging Python projects and managing virtual environments has become a lot easier in recent years if you know what you're doing, but if you don't, it can tend to look like an ocean of tools doing a lot of the same things. This section aims to clarify the differences between the various tools and how they fit together. The most popular tools are looked at in turn to evaluate their strengths and weaknesses, and how they can be used together. Skip to TL;DR for a summary of the findings of this section. Otherwise, head to the next page for a more in-depth look at the various tools available for packaging and project management.","title":"Packaging and Project Management Tools"},{"location":"tools/#tldr","text":"What follows is a brief overview of the differences between the tools that are evaluated, as well as their popularity.","title":"TL;DR"},{"location":"tools/#features","text":"pyproject.toml PEP 621 Compliant Virtual Environment Management Dependency Resolution Pinning Building Reproducible Builds Publishing Poetry PDM Pipenv Flit pip-tools Hatch","title":"Features"},{"location":"tools/#popularity","text":"These graphs show the number of stars on GitHub for each tool in relation to publication time. The graphs are generated using star-history .","title":"Popularity"},{"location":"tools/#comparison-using-absolute-publication-time","text":"This chart shows the popularity of each tool in relation to its publication time. The x-axis shows the date of publication, and the y-axis shows the number of stars on GitHub.","title":"Comparison Using Absolute Publication Time"},{"location":"tools/#comparison-using-relative-publication-time","text":"This chart shows the popularity of the tools in relation to the time since their publication. The x-axis shows number of years since publication, and the y-axis shows number of stars on GitHub.","title":"Comparison Using Relative Publication Time"},{"location":"tools/#unmentioned-tools","text":"","title":"Unmentioned Tools"},{"location":"tools/#twine","text":"","title":"Twine"},{"location":"tools/#enscons","text":"Tool for building source distributions and wheels without setuptools , including ones that require C extensions. PyPI link: https://pypi.org/project/enscons/","title":"Enscons"},{"location":"tools/#further-reading","text":"Below are the most relevant PEPs with regards to modern packaging and building of Python projects with pyproject.toml as well as other relevant reading material.","title":"Further Reading"},{"location":"tools/#peps","text":"PEP 518 - Specifying Minimum Build System Requirements for Python Projects PEP 621 - Storing project metadata in pyproject.toml","title":"PEPs"},{"location":"tools/#relevant-links","text":"Full list of modern packaging PEPs (508 and onwards) Clarifying PEP 518 (a.k.a. pyproject.toml) pyproject.toml specification TIL: pip-tools Supports pyproject.toml Hypermodern Python Insofar as GitHub stars are a good metric to determine this. https://pypi.org/project/darker/#:~:text=command%20line%20options-,Editor%20integration,-Many%20editors%20have https://moyix.blogspot.com/2022/09/someones-been-messing-with-my-subnormals.html#:~:text=I%20actually%20started,home%20directory.%20Convenient!","title":"Relevant Links"},{"location":"tools/all-in-one/","text":"All-in-One Tools The tools in this section perform the entire Python packaging and development process, from dependency resolution to publishing. They can still be used in conjunction with more specialized tools for certain workflows, but it is not required. This means they should be able to perform the following tasks: Virtual Environment management Dependency resolution Locking/pinning Building Publishing And optionally: Supports pyproject.toml PEP 621 compliant Reproducible builds","title":"All-in-One Tools"},{"location":"tools/all-in-one/#all-in-one-tools","text":"The tools in this section perform the entire Python packaging and development process, from dependency resolution to publishing. They can still be used in conjunction with more specialized tools for certain workflows, but it is not required. This means they should be able to perform the following tasks: Virtual Environment management Dependency resolution Locking/pinning Building Publishing And optionally: Supports pyproject.toml PEP 621 compliant Reproducible builds","title":"All-in-One Tools"},{"location":"tools/all-in-one/pdm/","text":"PDM Supports pyproject.toml ] PEP 621 compliant Virtual Environment management Dependency resolution Locking/pinning Building Reproducible builds 1 Publishing Stat Value First published 2021-04-12 Last updated 2022-08-30 GitHub stars 3,100 GitHub repo https://github.com/pdm-project/pdm PDM is an all-in-one tool in the vein of Poetry, but with a tighter PEP specfications compliance. It is able to resolve dependencies, lock them, and create a virtual environment with the correct dependencies installed. It is also able to export its dependencies and metadata as requirements.txt and setup.py in cases where this is required - though most of the time one will be building wheels and source distributions instead of manually exporting these files. PEP Compliance Unlike Poetry, PDM seeks to be PEP compliant, and uses the [project] table to store project metadata and dependencies. Furthermore, it includes opt-in support for the not-yet-accepted PEP 581, which introduces the __pypackages__ directory (similar to node_modules ) for storing dependencies. In general, it seems like PDM seeks to be as PEP compliant as possible, and it is a good choice when working with other tools that require strict pyproject.toml PEP compliance. Project Metadata PDM uses the standard [project] table to store project metadata. This means that the project metadata can be read without installing PDM when working with the package source code. # pyproject.toml [build-system] requires = [ \"pdm-pep517\" ] build-backend = \"pdm.pep517.api\" [project] name = \"my-package\" version = \"1.0.0\" description = \"\" authors = [{ name = \"Author Name\" , email = \"user@example.com\" }] requires-python = \">=3.10\" license = { text = \"MIT\" } readme = \"README.md\" keywords = [ \"keyword1\" , \"keyword2\" ] classifiers = [ \"Topic :: Software Development :: Build Tools\" , \"Topic :: Software Development :: Libraries :: Python Modules\" ] [project.urls] homepage = \"https://example.com\" repository = \"https://github.com/user/example\" documentation = \"https://example.com/docs\" Dependency Specification Dependencies are specified in the [project] table under the dependencies and optional-dependencies keys, according to the PEP 621 specification. Optional dependencies/extras are added via the CLI option -G/--group : pdm add -G dev pytest These are then exported to the generated setup.py as extras_require , meaning they can be installed with pip install my-package[dev] . # pyproject.toml # ... [project] # ... dependencies = [ \"httpx\" , \"fastapi\" , ] [project.optional-dependencies] dev = [ \"black\" , \"mypy\" , \"pytest\" , \"pre-commit\" ] docs = [ \"mkdocs\" , \"mkdocs-material\" ] If one wishes to not export these extras to setup.py , they can use the --d/--dev flag: pdm add --dev pytest This adds the dependency under the [tool.pdm.dev-dependencies] table, which is not exported to setup.py . # pyproject.toml # ... [project] # ... dependencies = [ \"httpx\" , \"fastapi\" , ] [tool] [tool.pdm] [tool.pdm.dev-dependencies] dev = [ \"pytest>=7.1.3\" , ] Extras Usage with Other Tools Although PDM includes its own build system tool, pdm-pep517 , it supports a multitude of build tools, including setuptools , flit , and hatch . Unlike Poetry, it is not tied a to specific proprietary build tool. Negatives The developer is a Chinese resident and works for Crypto.com 2 . Double whammy. However, the project is open source and the developer is active on GitHub. The project is also relatively new, so it's hard to tell how it will develop in the future. Summary PDM is a robust and powerful tool that is PEP compliant and supports a multitude of build systems, which means it's not tied to a specific properietary build system like Poetry. Its CLI is also very intuitive and easy to use. PDM is regularly updated, and the developer actively communicates on Twitter and GitHub. The major drawbacks are its relative newness, its lack of popularity compared to Poetry, and the fact that the developer is a Chinese resident and works for Crypto.com. However, it seems unlikely that a dependency management and publishing tool should be subject to any political or legal restrictions as a result of the developer's nationality. PDM is a tool that is worth keeping an eye on, and it's worth trying out if you're looking for a PEP compliant all-in-one dependency and project management tool that supports a multitude of build systems. Is it ready for production? It seems so, but it needs to be tested more thoroughly. It is unclear whether the default build system pdm-pep517 supports reproducible builds, but other supported build systems such as flit and hatch do. \u21a9 Spotted in the bio on https://dev.to/frostming/a-review-pipenv-vs-poetry-vs-pdm-39b4 . This information might be out-of-date. \u21a9","title":"PDM"},{"location":"tools/all-in-one/pdm/#pdm","text":"Supports pyproject.toml ] PEP 621 compliant Virtual Environment management Dependency resolution Locking/pinning Building Reproducible builds 1 Publishing Stat Value First published 2021-04-12 Last updated 2022-08-30 GitHub stars 3,100 GitHub repo https://github.com/pdm-project/pdm PDM is an all-in-one tool in the vein of Poetry, but with a tighter PEP specfications compliance. It is able to resolve dependencies, lock them, and create a virtual environment with the correct dependencies installed. It is also able to export its dependencies and metadata as requirements.txt and setup.py in cases where this is required - though most of the time one will be building wheels and source distributions instead of manually exporting these files.","title":"PDM"},{"location":"tools/all-in-one/pdm/#pep-compliance","text":"Unlike Poetry, PDM seeks to be PEP compliant, and uses the [project] table to store project metadata and dependencies. Furthermore, it includes opt-in support for the not-yet-accepted PEP 581, which introduces the __pypackages__ directory (similar to node_modules ) for storing dependencies. In general, it seems like PDM seeks to be as PEP compliant as possible, and it is a good choice when working with other tools that require strict pyproject.toml PEP compliance.","title":"PEP Compliance"},{"location":"tools/all-in-one/pdm/#project-metadata","text":"PDM uses the standard [project] table to store project metadata. This means that the project metadata can be read without installing PDM when working with the package source code. # pyproject.toml [build-system] requires = [ \"pdm-pep517\" ] build-backend = \"pdm.pep517.api\" [project] name = \"my-package\" version = \"1.0.0\" description = \"\" authors = [{ name = \"Author Name\" , email = \"user@example.com\" }] requires-python = \">=3.10\" license = { text = \"MIT\" } readme = \"README.md\" keywords = [ \"keyword1\" , \"keyword2\" ] classifiers = [ \"Topic :: Software Development :: Build Tools\" , \"Topic :: Software Development :: Libraries :: Python Modules\" ] [project.urls] homepage = \"https://example.com\" repository = \"https://github.com/user/example\" documentation = \"https://example.com/docs\"","title":"Project Metadata"},{"location":"tools/all-in-one/pdm/#dependency-specification","text":"Dependencies are specified in the [project] table under the dependencies and optional-dependencies keys, according to the PEP 621 specification. Optional dependencies/extras are added via the CLI option -G/--group : pdm add -G dev pytest These are then exported to the generated setup.py as extras_require , meaning they can be installed with pip install my-package[dev] . # pyproject.toml # ... [project] # ... dependencies = [ \"httpx\" , \"fastapi\" , ] [project.optional-dependencies] dev = [ \"black\" , \"mypy\" , \"pytest\" , \"pre-commit\" ] docs = [ \"mkdocs\" , \"mkdocs-material\" ] If one wishes to not export these extras to setup.py , they can use the --d/--dev flag: pdm add --dev pytest This adds the dependency under the [tool.pdm.dev-dependencies] table, which is not exported to setup.py . # pyproject.toml # ... [project] # ... dependencies = [ \"httpx\" , \"fastapi\" , ] [tool] [tool.pdm] [tool.pdm.dev-dependencies] dev = [ \"pytest>=7.1.3\" , ]","title":"Dependency Specification"},{"location":"tools/all-in-one/pdm/#extras","text":"","title":"Extras"},{"location":"tools/all-in-one/pdm/#usage-with-other-tools","text":"Although PDM includes its own build system tool, pdm-pep517 , it supports a multitude of build tools, including setuptools , flit , and hatch . Unlike Poetry, it is not tied a to specific proprietary build tool.","title":"Usage with Other Tools"},{"location":"tools/all-in-one/pdm/#negatives","text":"The developer is a Chinese resident and works for Crypto.com 2 . Double whammy. However, the project is open source and the developer is active on GitHub. The project is also relatively new, so it's hard to tell how it will develop in the future.","title":"Negatives"},{"location":"tools/all-in-one/pdm/#summary","text":"PDM is a robust and powerful tool that is PEP compliant and supports a multitude of build systems, which means it's not tied to a specific properietary build system like Poetry. Its CLI is also very intuitive and easy to use. PDM is regularly updated, and the developer actively communicates on Twitter and GitHub. The major drawbacks are its relative newness, its lack of popularity compared to Poetry, and the fact that the developer is a Chinese resident and works for Crypto.com. However, it seems unlikely that a dependency management and publishing tool should be subject to any political or legal restrictions as a result of the developer's nationality. PDM is a tool that is worth keeping an eye on, and it's worth trying out if you're looking for a PEP compliant all-in-one dependency and project management tool that supports a multitude of build systems. Is it ready for production? It seems so, but it needs to be tested more thoroughly. It is unclear whether the default build system pdm-pep517 supports reproducible builds, but other supported build systems such as flit and hatch do. \u21a9 Spotted in the bio on https://dev.to/frostming/a-review-pipenv-vs-poetry-vs-pdm-39b4 . This information might be out-of-date. \u21a9","title":"Summary"},{"location":"tools/all-in-one/pipenv/","text":"Pipenv Supports pyproject.toml PEP 621 compliant Virtual Environment management Dependency resolution Locking/pinning Building Reproducible builds Publishing Stat Value First published 2017-01-20 Last updated 2022-09-08 GitHub stars 23,300 GitHub repo https://github.com/pypa/pipenv Introduction Pipenv was one of the first tools released to address the problems with Python packaging. It is a tool that combines pip and virtualenv into a single tool. It is able to resolve dependencies, lock them, and create a virtual environment with the correct dependencies installed. It is also able to generate a requirements.txt file for use with pip . However, it is not able to build packages and does not support pyproject.toml . It is also famously slow when resolving numerous dependencies. n Due to its lack of support for pyproject.toml , Pipenv can not be used in conjunction with the other tools in this section. It is also not able to build packages, so it is not possible to use it to build a package and then use another tool to publish it. Summary Pipenv has been superceded by more modern tools such as Poetry and PDM both in terms of features and performance. New projects should probably not use this tool. It is only included here for completeness given its historical popularity.","title":"Pipenv"},{"location":"tools/all-in-one/pipenv/#pipenv","text":"Supports pyproject.toml PEP 621 compliant Virtual Environment management Dependency resolution Locking/pinning Building Reproducible builds Publishing Stat Value First published 2017-01-20 Last updated 2022-09-08 GitHub stars 23,300 GitHub repo https://github.com/pypa/pipenv","title":"Pipenv"},{"location":"tools/all-in-one/pipenv/#introduction","text":"Pipenv was one of the first tools released to address the problems with Python packaging. It is a tool that combines pip and virtualenv into a single tool. It is able to resolve dependencies, lock them, and create a virtual environment with the correct dependencies installed. It is also able to generate a requirements.txt file for use with pip . However, it is not able to build packages and does not support pyproject.toml . It is also famously slow when resolving numerous dependencies. n Due to its lack of support for pyproject.toml , Pipenv can not be used in conjunction with the other tools in this section. It is also not able to build packages, so it is not possible to use it to build a package and then use another tool to publish it.","title":"Introduction"},{"location":"tools/all-in-one/pipenv/#summary","text":"Pipenv has been superceded by more modern tools such as Poetry and PDM both in terms of features and performance. New projects should probably not use this tool. It is only included here for completeness given its historical popularity.","title":"Summary"},{"location":"tools/all-in-one/poetry/","text":"Poetry Supports pyproject.toml PEP 621 compliant Virtual Environment management Dependency resolution Locking/pinning Building Reproducible builds Publishing Stat Value First published 2018-02-28 Last updated 2022-08-31 GitHub stars 21,700 GitHub repo https://github.com/python-poetry/poetry Introduction Poetry is the most popular Python packaging tool in recent years. It is a tool that, like Pipenv , combines pip and virtualenv to automatically create virtual environments, resolve dependencies, and install them. Furthermore, it is also able to build packages and publish them to PyPI. It is an all-in-one tool that is able to do everything that Pipenv can do, and more. Poetry can build Python source and wheel distributions and publish them to PyPI. The distributions it builds include automatically generated metadata, such as PKG-INFO and setup.py files, which ensure compatibility with older versions of pip . It is also able to generate a requirements.txt file for use with installations that do not require packaging, such as Docker images. Its performance is better than that of Pipenv , but not as fast as PDM . 1 Speed of tooling is not paramount, as it is only run occasionally, but it is still worth noting. PEP Compliance Poetry supports pyproject.toml , but does not fully implement PEP 621. It is able to read the pyproject.toml file, but it uses its own dependency specification, which is in turn built using the poetry-core build system (not setuptools ). It stores all project metadata under [tool.poetry[.key]] tables in the pyproject.toml file. The key names are for the most part identical to the PEP621 specification. To specify optional (non-distributed) dependencies Poetry uses something called \"dependency group\" tables in the form of [tool.poetry.group.<groupname>.dependencies] . Distributed optional dependencies are specified in the [tool.poetry.extras] table. The key names are the same as the group names, and the values are lists of dependencies. See Extras for more information Project Metadata Poetry's equivalent of the [project] table is [tool.poetry] . As a result of this non-standard approach, the project metadata cannot be read without installing Poetry when working with the package source code. However, this information is included in the generated setup.py in the distributions built by Poetry. This means that pip is able to read the project metadata natively when installing package distributions built with Poetry. The end user will not notice any difference in the installation process. # pyproject.toml [build-system] requires = [ \"poetry-core>=1.0.0\" ] build-backend = \"poetry.core.masonry.api\" [tool.poetry] name = \"my-package\" version = \"0.1.0\" description = \"A short description of my package\" license = \"MIT\" authors = [ \"Author Name <user@example.com>\" ] maintainers = [ \"Author Name <user2@example.com>\" , \"Author Name <user3@example.com>\" , ] readme = \"README.md\" homepage = \"https://example.com\" repository = \"https://github.com/user/example\" documentation = \"https://example.com/docs\" keywords = [ \"keyword1\" , \"keyword2\" ] classifiers = [ \"Topic :: Software Development :: Build Tools\" , \"Topic :: Software Development :: Libraries :: Python Modules\" ] Poetry uses the non-standard fields homepage , repository and documentation , which are usually found under the [project.urls] table in PEP 621. See PDM: Project Metadata for more information on how this information is specified in accordance with the spec. Dependency Specification Example of the Poetry dependency specification: # pyproject.toml # ... [tool.poetry.dependencies] requests = \"^2.13.0\" [tool.poetry.group.test] optional = true [tool.poetry.group.test.dependencies] pytest = \"^7.0.0\" pytest-mock = \"*\" The code snippet demonstrates specification of required dependencies as well as optional dependencies with dependency groups. Required dependencies are added via the following command: poetry add requests Optional dependencies (dependency groups) are added via the following command: poetry add pytest --group test The optional key in the [tool.poetry.group.test] table is used to specify whether the dependency group is optional or not. Dependency groups are resolved and installed by default unless optional = true is added to its group table. This can be a bit confusing, since one would expect dependencies specified apart from the dependencies table to be optional by default, but they are NOT . Dependency groups are simply a way to label dependencies, not a way to specify optional dependencies/extras in the same way as PEP 621. This is a bit confusing, but it is possible to use the extras table to specify extras. When using the Poetry CLI, optional dependency groups can be installed using the --with flag. This can be useful in CI workflows, where you want certain optional packages for workflows such as documentation generation or testing, but you don't want to expose these dependencies as installable extras to the end user. Example: poetry install --with test # required dependencies + testing dependencies are installed pytest Extras Dependency groups do not specify the traditional \"extras\" that can be installed with pip using the package[extra] syntax. Instead, extras are specified in the [tool.poetry.extras] table. # pyproject.toml [tool.poetry] name = \"my-package\" [tool.poetry.dependencies] requests = \"^2.13.0\" psycopg2 = { version = \"^2.9\" , optional = true } mysqlclient = { version = \"^1.3\" , optional = true } [tool.poetry.extras] mysql = [ \"mysqlclient\" ] pgsql = [ \"psycopg2\" ] databases = [ \"mysqlclient\" , \"psycopg2\" ] To add a dependency as an extra, the following command is used: poetry add --optional mysqlclient The extra table then has to be manually updated to include the dependency and given an extra name. There is no CLI option for this. When published, the package can then be installed with pip using the [extra] syntax: pip install my-package [ mysql ] Usage with Other Tools Poetry is an all-in-one-tool, and as such it is not necessary to use it with other tools. Also, given its non-compliant approach to project metadata, it is dubious whether it's possible to use it with other tools that require the project metadata to be available in the pyproject.toml file. [n] Negatives With the release of version 1.2.0, the Poetry developers attempted to implement a random \"brownout\" that would cause Poetry installations to intermittently fail in CI when installed via a deprecated installation method. This affected previous versions as well, breaking people's CI builds of old versions with the installation script. 2 This sort of action speaks poorly of the developers' judgement, and lessens the community's trust in them with regards to future changes. They walked back on the decision, but it still reflects poorly on the developers. Furthermore, Poetry's lack of PEP compliance makes it more difficult to use alongside other tools. Summary Poetry is a battle tested tool that is ever-growing in popularity. It is on track to eclipse Pipenv in popularity in under 5 years of existence. It supports the new pyproject.toml format, and is good choice for self-contained projects that do not rely on other packaging and project management tools. It has a robust CLI that is easy to use. However, it is not compliant with PEP 621, and as such it is likely not possible to use it with other tools that require the project metadata to be available in the pyproject.toml file. 3 This is a major drawback, and it is not clear whether the developers are willing to change this. Furthermore, it is unclear what the long term implications of this non-compliance will be. As long as Poetry is the only packaging and dependency management tool used in a project, it is a good choice. However, if you want to use other packaging or build tools in conjunction with a dependency management tool, PDM might be a better option. A Review: Pipenv vs. Poetry vs. PDM . Note: this was written by the developer of PDM, so take it with a grain of salt. \u21a9 refactor: rework deprecation of get-poetry.py to include CI brownout and restructured messaging \u21a9 This claim has not been verified. \u21a9","title":"Poetry"},{"location":"tools/all-in-one/poetry/#poetry","text":"Supports pyproject.toml PEP 621 compliant Virtual Environment management Dependency resolution Locking/pinning Building Reproducible builds Publishing Stat Value First published 2018-02-28 Last updated 2022-08-31 GitHub stars 21,700 GitHub repo https://github.com/python-poetry/poetry","title":"Poetry"},{"location":"tools/all-in-one/poetry/#introduction","text":"Poetry is the most popular Python packaging tool in recent years. It is a tool that, like Pipenv , combines pip and virtualenv to automatically create virtual environments, resolve dependencies, and install them. Furthermore, it is also able to build packages and publish them to PyPI. It is an all-in-one tool that is able to do everything that Pipenv can do, and more. Poetry can build Python source and wheel distributions and publish them to PyPI. The distributions it builds include automatically generated metadata, such as PKG-INFO and setup.py files, which ensure compatibility with older versions of pip . It is also able to generate a requirements.txt file for use with installations that do not require packaging, such as Docker images. Its performance is better than that of Pipenv , but not as fast as PDM . 1 Speed of tooling is not paramount, as it is only run occasionally, but it is still worth noting.","title":"Introduction"},{"location":"tools/all-in-one/poetry/#pep-compliance","text":"Poetry supports pyproject.toml , but does not fully implement PEP 621. It is able to read the pyproject.toml file, but it uses its own dependency specification, which is in turn built using the poetry-core build system (not setuptools ). It stores all project metadata under [tool.poetry[.key]] tables in the pyproject.toml file. The key names are for the most part identical to the PEP621 specification. To specify optional (non-distributed) dependencies Poetry uses something called \"dependency group\" tables in the form of [tool.poetry.group.<groupname>.dependencies] . Distributed optional dependencies are specified in the [tool.poetry.extras] table. The key names are the same as the group names, and the values are lists of dependencies. See Extras for more information","title":"PEP Compliance"},{"location":"tools/all-in-one/poetry/#project-metadata","text":"Poetry's equivalent of the [project] table is [tool.poetry] . As a result of this non-standard approach, the project metadata cannot be read without installing Poetry when working with the package source code. However, this information is included in the generated setup.py in the distributions built by Poetry. This means that pip is able to read the project metadata natively when installing package distributions built with Poetry. The end user will not notice any difference in the installation process. # pyproject.toml [build-system] requires = [ \"poetry-core>=1.0.0\" ] build-backend = \"poetry.core.masonry.api\" [tool.poetry] name = \"my-package\" version = \"0.1.0\" description = \"A short description of my package\" license = \"MIT\" authors = [ \"Author Name <user@example.com>\" ] maintainers = [ \"Author Name <user2@example.com>\" , \"Author Name <user3@example.com>\" , ] readme = \"README.md\" homepage = \"https://example.com\" repository = \"https://github.com/user/example\" documentation = \"https://example.com/docs\" keywords = [ \"keyword1\" , \"keyword2\" ] classifiers = [ \"Topic :: Software Development :: Build Tools\" , \"Topic :: Software Development :: Libraries :: Python Modules\" ] Poetry uses the non-standard fields homepage , repository and documentation , which are usually found under the [project.urls] table in PEP 621. See PDM: Project Metadata for more information on how this information is specified in accordance with the spec.","title":"Project Metadata"},{"location":"tools/all-in-one/poetry/#dependency-specification","text":"Example of the Poetry dependency specification: # pyproject.toml # ... [tool.poetry.dependencies] requests = \"^2.13.0\" [tool.poetry.group.test] optional = true [tool.poetry.group.test.dependencies] pytest = \"^7.0.0\" pytest-mock = \"*\" The code snippet demonstrates specification of required dependencies as well as optional dependencies with dependency groups. Required dependencies are added via the following command: poetry add requests Optional dependencies (dependency groups) are added via the following command: poetry add pytest --group test The optional key in the [tool.poetry.group.test] table is used to specify whether the dependency group is optional or not. Dependency groups are resolved and installed by default unless optional = true is added to its group table. This can be a bit confusing, since one would expect dependencies specified apart from the dependencies table to be optional by default, but they are NOT . Dependency groups are simply a way to label dependencies, not a way to specify optional dependencies/extras in the same way as PEP 621. This is a bit confusing, but it is possible to use the extras table to specify extras. When using the Poetry CLI, optional dependency groups can be installed using the --with flag. This can be useful in CI workflows, where you want certain optional packages for workflows such as documentation generation or testing, but you don't want to expose these dependencies as installable extras to the end user. Example: poetry install --with test # required dependencies + testing dependencies are installed pytest","title":"Dependency Specification"},{"location":"tools/all-in-one/poetry/#extras","text":"Dependency groups do not specify the traditional \"extras\" that can be installed with pip using the package[extra] syntax. Instead, extras are specified in the [tool.poetry.extras] table. # pyproject.toml [tool.poetry] name = \"my-package\" [tool.poetry.dependencies] requests = \"^2.13.0\" psycopg2 = { version = \"^2.9\" , optional = true } mysqlclient = { version = \"^1.3\" , optional = true } [tool.poetry.extras] mysql = [ \"mysqlclient\" ] pgsql = [ \"psycopg2\" ] databases = [ \"mysqlclient\" , \"psycopg2\" ] To add a dependency as an extra, the following command is used: poetry add --optional mysqlclient The extra table then has to be manually updated to include the dependency and given an extra name. There is no CLI option for this. When published, the package can then be installed with pip using the [extra] syntax: pip install my-package [ mysql ]","title":"Extras"},{"location":"tools/all-in-one/poetry/#usage-with-other-tools","text":"Poetry is an all-in-one-tool, and as such it is not necessary to use it with other tools. Also, given its non-compliant approach to project metadata, it is dubious whether it's possible to use it with other tools that require the project metadata to be available in the pyproject.toml file. [n]","title":"Usage with Other Tools"},{"location":"tools/all-in-one/poetry/#negatives","text":"With the release of version 1.2.0, the Poetry developers attempted to implement a random \"brownout\" that would cause Poetry installations to intermittently fail in CI when installed via a deprecated installation method. This affected previous versions as well, breaking people's CI builds of old versions with the installation script. 2 This sort of action speaks poorly of the developers' judgement, and lessens the community's trust in them with regards to future changes. They walked back on the decision, but it still reflects poorly on the developers. Furthermore, Poetry's lack of PEP compliance makes it more difficult to use alongside other tools.","title":"Negatives"},{"location":"tools/all-in-one/poetry/#summary","text":"Poetry is a battle tested tool that is ever-growing in popularity. It is on track to eclipse Pipenv in popularity in under 5 years of existence. It supports the new pyproject.toml format, and is good choice for self-contained projects that do not rely on other packaging and project management tools. It has a robust CLI that is easy to use. However, it is not compliant with PEP 621, and as such it is likely not possible to use it with other tools that require the project metadata to be available in the pyproject.toml file. 3 This is a major drawback, and it is not clear whether the developers are willing to change this. Furthermore, it is unclear what the long term implications of this non-compliance will be. As long as Poetry is the only packaging and dependency management tool used in a project, it is a good choice. However, if you want to use other packaging or build tools in conjunction with a dependency management tool, PDM might be a better option. A Review: Pipenv vs. Poetry vs. PDM . Note: this was written by the developer of PDM, so take it with a grain of salt. \u21a9 refactor: rework deprecation of get-poetry.py to include CI brownout and restructured messaging \u21a9 This claim has not been verified. \u21a9","title":"Summary"},{"location":"tools/specialized/","text":"Specialized Tools The tools in this category perform a subset of the Python packaging and development process, but not all of it. They are often used in conjunction with other tools (and indeed each other) to achieve a complete workflow. This means they should be able to perform one or more of the following tasks: Virtual Environment management Dependency resolution Locking/pinning Building Reproducible builds Publishing And optionally: Supports pyproject.toml PEP 621 compliant","title":"Specialized Tools"},{"location":"tools/specialized/#specialized-tools","text":"The tools in this category perform a subset of the Python packaging and development process, but not all of it. They are often used in conjunction with other tools (and indeed each other) to achieve a complete workflow. This means they should be able to perform one or more of the following tasks: Virtual Environment management Dependency resolution Locking/pinning Building Reproducible builds Publishing And optionally: Supports pyproject.toml PEP 621 compliant","title":"Specialized Tools"},{"location":"tools/specialized/flit/","text":"Flit Supports pyproject.toml Virtual Environment management Dependency resolution Locking/pinning Building * Reproducible builds Publishing Stat Value First published 2015-03-16 Last updated 2022-02-23 GitHub stars 1,800 GitHub repo https://github.com/pypa/flit Flit is a tool used to build packages deterministically and reproducibly. It is able to build and publish packages using pyproject.toml . It is not able to resolve dependencies, lock them, or create virtual environments. Flit is an official PyPA project, and is used by certain large projects such as FastAPI . Given that it does not support dependency resolution, it PEP Compliance Flit is compliant with PEP 517 , PEP 518 and PEP 621 . Project Metadata Project metadata is specified in the [project] table in the pyproject.toml file, as specified by PEP 621. # pyproject.toml [build-system] requires = [ \"flit_core >=3.2,<4\" ] build-backend = \"flit_core.buildapi\" [project] name = \"foobar\" authors = [{ name = \"Sir Robin\" , email = \"robin@camelot.uk\" }] dynamic = [ \"version\" , \"description\" ] [project.urls] Home = \"https://github.com/sirrobin/foobar\" Example from the official documentation . Dependency Specification Uses standard PEP 621 dependency specification. # pyproject.toml # ... [project] # ... dependencies = [ \"django\" ] [project.optional-dependencies] dev = [ \"pytest\" ] Usage with Other Tools Flit can be used in conjunction with other tools that complements its functionality such as pip-tools . It can also be used as a build backend for PDM . Negatives Flit is not able to build packages that require a build step, such as those that use Cython or C extensions. Not very actively maintained, with the last release being in February 2022. Summary Due its relatively inactive development, Hatch is likely a better choice over Flit with regards to future-proofing. However, Flit is a good choice right now for those who are looking for a simple tool that is able to build and publish packages deterministically and reproducibly.","title":"Flit"},{"location":"tools/specialized/flit/#flit","text":"Supports pyproject.toml Virtual Environment management Dependency resolution Locking/pinning Building * Reproducible builds Publishing Stat Value First published 2015-03-16 Last updated 2022-02-23 GitHub stars 1,800 GitHub repo https://github.com/pypa/flit Flit is a tool used to build packages deterministically and reproducibly. It is able to build and publish packages using pyproject.toml . It is not able to resolve dependencies, lock them, or create virtual environments. Flit is an official PyPA project, and is used by certain large projects such as FastAPI . Given that it does not support dependency resolution, it","title":"Flit"},{"location":"tools/specialized/flit/#pep-compliance","text":"Flit is compliant with PEP 517 , PEP 518 and PEP 621 .","title":"PEP Compliance"},{"location":"tools/specialized/flit/#project-metadata","text":"Project metadata is specified in the [project] table in the pyproject.toml file, as specified by PEP 621. # pyproject.toml [build-system] requires = [ \"flit_core >=3.2,<4\" ] build-backend = \"flit_core.buildapi\" [project] name = \"foobar\" authors = [{ name = \"Sir Robin\" , email = \"robin@camelot.uk\" }] dynamic = [ \"version\" , \"description\" ] [project.urls] Home = \"https://github.com/sirrobin/foobar\" Example from the official documentation .","title":"Project Metadata"},{"location":"tools/specialized/flit/#dependency-specification","text":"Uses standard PEP 621 dependency specification. # pyproject.toml # ... [project] # ... dependencies = [ \"django\" ] [project.optional-dependencies] dev = [ \"pytest\" ]","title":"Dependency Specification"},{"location":"tools/specialized/flit/#usage-with-other-tools","text":"Flit can be used in conjunction with other tools that complements its functionality such as pip-tools . It can also be used as a build backend for PDM .","title":"Usage with Other Tools"},{"location":"tools/specialized/flit/#negatives","text":"Flit is not able to build packages that require a build step, such as those that use Cython or C extensions. Not very actively maintained, with the last release being in February 2022.","title":"Negatives"},{"location":"tools/specialized/flit/#summary","text":"Due its relatively inactive development, Hatch is likely a better choice over Flit with regards to future-proofing. However, Flit is a good choice right now for those who are looking for a simple tool that is able to build and publish packages deterministically and reproducibly.","title":"Summary"},{"location":"tools/specialized/hatch/","text":"Hatch Supports pyproject.toml PEP 621 compliant Virtual Environment management Dependency resolution Locking/pinning Building Reproducible builds Publishing Stat Value First published 2018-12-29 Last updated 2022-08-28 GitHub stars 3,000 GitHub repo https://github.com/pypa/hatch Hatch is a \"modern, extensible Python project manager.\"[^1] It has support for creating projects, building and publishing packages, and managing virtual environments. It utilizes pyproject.toml and is PEP 621 compliant. It does not, however, contain a dependency resolver or any way to add dependencies via its CLI. Hatch features a number of ways to control project generation using configurable templates. These templates include automatically adding license files, READMEs, test directories and even GitHub actions workflows. PEP Compliance Hatch utilizes pyproject.toml and is PEP 621 compliant. Project Metadata # pyproject.toml [build-system] requires = [ \"hatchling\" ] build-backend = \"hatchling.build\" [project] name = \"my-cool-django-app\" version = \"42\" # ... Dependency Specification Uses standard PEP 621 dependency specification. # pyproject.toml # ... [project] # ... dependencies = [ \"django\" ] [project.optional-dependencies] dev = [ \"pytest\" ] Usage with Other Tools Negatives Hatch does not have a dependency resolver or any way to add dependencies via its CLI. It requires a manual workflow of manually adding dependencies to pyproject.toml . In this regard, it's simply a modern replacement for existing workflows where manual editing of setup.py and requirements.txt was required. Summary Hatch is a mature and well-supported tool for building and publishing Python projects. It is able to read from pyproject.toml and is PEP 621 compliant. It is a project management tool as well as a build system, and is able to create reproducible builds and publish packages to PyPI. Its configuration options and templates enable powerful workflows that are useful when creating new projects. In many ways Hatch can do everything that Poetry and PDM can, except for dependency resolution. If you are ok with specifying dependencies manually, Hatch is an excellent tool.","title":"Hatch"},{"location":"tools/specialized/hatch/#hatch","text":"Supports pyproject.toml PEP 621 compliant Virtual Environment management Dependency resolution Locking/pinning Building Reproducible builds Publishing Stat Value First published 2018-12-29 Last updated 2022-08-28 GitHub stars 3,000 GitHub repo https://github.com/pypa/hatch Hatch is a \"modern, extensible Python project manager.\"[^1] It has support for creating projects, building and publishing packages, and managing virtual environments. It utilizes pyproject.toml and is PEP 621 compliant. It does not, however, contain a dependency resolver or any way to add dependencies via its CLI. Hatch features a number of ways to control project generation using configurable templates. These templates include automatically adding license files, READMEs, test directories and even GitHub actions workflows.","title":"Hatch"},{"location":"tools/specialized/hatch/#pep-compliance","text":"Hatch utilizes pyproject.toml and is PEP 621 compliant.","title":"PEP Compliance"},{"location":"tools/specialized/hatch/#project-metadata","text":"# pyproject.toml [build-system] requires = [ \"hatchling\" ] build-backend = \"hatchling.build\" [project] name = \"my-cool-django-app\" version = \"42\" # ...","title":"Project Metadata"},{"location":"tools/specialized/hatch/#dependency-specification","text":"Uses standard PEP 621 dependency specification. # pyproject.toml # ... [project] # ... dependencies = [ \"django\" ] [project.optional-dependencies] dev = [ \"pytest\" ]","title":"Dependency Specification"},{"location":"tools/specialized/hatch/#usage-with-other-tools","text":"","title":"Usage with Other Tools"},{"location":"tools/specialized/hatch/#negatives","text":"Hatch does not have a dependency resolver or any way to add dependencies via its CLI. It requires a manual workflow of manually adding dependencies to pyproject.toml . In this regard, it's simply a modern replacement for existing workflows where manual editing of setup.py and requirements.txt was required.","title":"Negatives"},{"location":"tools/specialized/hatch/#summary","text":"Hatch is a mature and well-supported tool for building and publishing Python projects. It is able to read from pyproject.toml and is PEP 621 compliant. It is a project management tool as well as a build system, and is able to create reproducible builds and publish packages to PyPI. Its configuration options and templates enable powerful workflows that are useful when creating new projects. In many ways Hatch can do everything that Poetry and PDM can, except for dependency resolution. If you are ok with specifying dependencies manually, Hatch is an excellent tool.","title":"Summary"},{"location":"tools/specialized/pip-tools/","text":"pip-tools Supports pyproject.toml PEP 621 compliant Virtual Environment management Dependency resolution* Locking/pinning Building Reproducible builds Publishing Stat Value First published 2012-09-26 Last updated 2022-06-30 GitHub stars 6,200 GitHub repo https://github.com/jazzband/pip-tools https://pip-tools.readthedocs.io/en/latest/ pip-tools is a tool that is able to pin dependencies and generate requirements.txt files. It is not able to build packages, or publish them. It is a useful tool for pinning dependencies in order to ensure deterministic builds. pip-tools can read from pyproject.toml . pip-tools is best used in conjunction with tools such as Flit and Hatch , which handle the building and publishing of packages. Only pins packages and creates requirements.txt , dev-requirements.txt , etc. Supports pyproject.toml PEP Compliance Project Metadata N/A Dependency Specification Uses standard PEP 621 dependency specification. Example from pip-tools 's documentation: # pyproject.toml [build-system] requires = [ \"hatchling\" ] build-backend = \"hatchling.build\" [project] name = \"my-cool-django-app\" version = \"42\" dependencies = [ \"django\" ] [project.optional-dependencies] dev = [ \"pytest\" ] Extras Able to create pinned dev-requirements.txt , test-requirements.txt , etc. for use with pip install -r from pyproject.toml . Usage with Other Tools pip-tools is best used in conjunction with tools such as Flit and Hatch , which handle the building and publishing of packages. It is not a replacement for a full-featured dependency resolver such as Poetry or PDM . Negatives The tool is limited, and is not a full replacement for any of the other tools mentioned here. This is not a negative per se, but it is important to understand what the tool is and is not capable of doing. Summary This is a tool best used in conjunction with a tool such as Hatch or flit . pip-tools can handle the pinning of dependencies specified in pyproject.toml , while Hatch and flit can handle the building and publishing of packages. It is a bit more of a manual process than the all-in-one tools, but it is a useful tool for pinning dependencies in order to ensure deterministic builds, if that is a requirement for your project.","title":"pip-tools"},{"location":"tools/specialized/pip-tools/#pip-tools","text":"Supports pyproject.toml PEP 621 compliant Virtual Environment management Dependency resolution* Locking/pinning Building Reproducible builds Publishing Stat Value First published 2012-09-26 Last updated 2022-06-30 GitHub stars 6,200 GitHub repo https://github.com/jazzband/pip-tools https://pip-tools.readthedocs.io/en/latest/ pip-tools is a tool that is able to pin dependencies and generate requirements.txt files. It is not able to build packages, or publish them. It is a useful tool for pinning dependencies in order to ensure deterministic builds. pip-tools can read from pyproject.toml . pip-tools is best used in conjunction with tools such as Flit and Hatch , which handle the building and publishing of packages. Only pins packages and creates requirements.txt , dev-requirements.txt , etc. Supports pyproject.toml","title":"pip-tools"},{"location":"tools/specialized/pip-tools/#pep-compliance","text":"","title":"PEP Compliance"},{"location":"tools/specialized/pip-tools/#project-metadata","text":"N/A","title":"Project Metadata"},{"location":"tools/specialized/pip-tools/#dependency-specification","text":"Uses standard PEP 621 dependency specification. Example from pip-tools 's documentation: # pyproject.toml [build-system] requires = [ \"hatchling\" ] build-backend = \"hatchling.build\" [project] name = \"my-cool-django-app\" version = \"42\" dependencies = [ \"django\" ] [project.optional-dependencies] dev = [ \"pytest\" ]","title":"Dependency Specification"},{"location":"tools/specialized/pip-tools/#extras","text":"Able to create pinned dev-requirements.txt , test-requirements.txt , etc. for use with pip install -r from pyproject.toml .","title":"Extras"},{"location":"tools/specialized/pip-tools/#usage-with-other-tools","text":"pip-tools is best used in conjunction with tools such as Flit and Hatch , which handle the building and publishing of packages. It is not a replacement for a full-featured dependency resolver such as Poetry or PDM .","title":"Usage with Other Tools"},{"location":"tools/specialized/pip-tools/#negatives","text":"The tool is limited, and is not a full replacement for any of the other tools mentioned here. This is not a negative per se, but it is important to understand what the tool is and is not capable of doing.","title":"Negatives"},{"location":"tools/specialized/pip-tools/#summary","text":"This is a tool best used in conjunction with a tool such as Hatch or flit . pip-tools can handle the pinning of dependencies specified in pyproject.toml , while Hatch and flit can handle the building and publishing of packages. It is a bit more of a manual process than the all-in-one tools, but it is a useful tool for pinning dependencies in order to ensure deterministic builds, if that is a requirement for your project.","title":"Summary"}]}